{"version":3,"names":["_core","require","_normalizeAndLoadMetadata","toGetWrapperPayload","lazy","source","metadata","isSideEffectImport","reexportAll","includes","Array","isArray","Error","wrapReference","ref","payload","t","callExpression"],"sources":["../src/lazy-modules.ts"],"sourcesContent":["// TODO: Move `lazy` implementation logic into the CommonJS plugin, since other\n// modules systems do not support `lazy`.\n\nimport { types as t } from \"@babel/core\";\nimport {\n  type SourceModuleMetadata,\n  isSideEffectImport,\n} from \"./normalize-and-load-metadata.ts\";\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport function toGetWrapperPayload(lazy: Lazy) {\n  return (source: string, metadata: SourceModuleMetadata): null | \"lazy\" => {\n    if (lazy === false) return null;\n    if (isSideEffectImport(metadata) || metadata.reexportAll) return null;\n    if (lazy === true) {\n      // 'true' means that local relative files are eagerly loaded and\n      // dependency modules are loaded lazily.\n      return source.includes(\".\") ? null : \"lazy\";\n    }\n    if (Array.isArray(lazy)) {\n      return !lazy.includes(source) ? null : \"lazy\";\n    }\n    if (typeof lazy === \"function\") {\n      return lazy(source) ? \"lazy\" : null;\n    }\n    throw new Error(`.lazy must be a boolean, string array, or function`);\n  };\n}\n\nexport function wrapReference(\n  ref: t.Identifier,\n  payload: unknown,\n): t.Expression | null {\n  if (payload === \"lazy\") return t.callExpression(ref, []);\n  return null;\n}\n"],"mappings":";;;;;;;AAGA,IAAAA,KAAA,GAAA